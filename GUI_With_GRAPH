import sys
import os
import bge
import math
import mathutils
import traceback
import logging
import time
import pyqtgraph as pg
import numpy as np

# from PyQt5.QtWidgets import (
#         QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
#         QPushButton, QTabWidget, QFormLayout, QListWidget, QListWidgetItem, QMessageBox,
#         QSplitter, QScrollArea
#     )

from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QTabWidget, QFormLayout, QListWidget, QListWidgetItem, QMessageBox,
    QSplitter, QScrollArea
)
from PyQt5.QtCore import QTimer, Qt
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QScrollArea, QWidget, QVBoxLayout, QLineEdit

# Configure logging
log_file_path = os.path.join(bge.logic.expandPath("//"), "bge_debugger.log")
logging.basicConfig(
    filename=log_file_path,
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logging.info("BGE Debugger started")

    
class DebuggerWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BGE Debugger")
        self.setGeometry(100, 100, 800, 600)  # Increased width to accommodate the graph

        # Main Layouts
        self.main_layout = QVBoxLayout(self)
        self.setLayout(self.main_layout)
        # self.main_layout = QHBoxLayout()  # Changed to QHBoxLayout
        self.left_layout = QVBoxLayout()
        self.right_layout = QVBoxLayout()

        # Initialize sub-layouts
        self.control_layout = QHBoxLayout()
        self.search_layout = QHBoxLayout()

        # Game Controls
        self.fps_input = QLineEdit("60")
        self.fps_input.setFixedWidth(50)
        self.fps_button = QPushButton("Set FPS")
        self.fps_button.clicked.connect(self.set_fps)

        self.speed_input = QLineEdit("1.0")
        self.speed_input.setFixedWidth(50)
        self.speed_button = QPushButton("Set Game Speed")
        self.speed_button.clicked.connect(self.set_game_speed)

        self.pause_button = QPushButton("Pause")
        self.pause_button.clicked.connect(self.pause_game)
        self.play_button = QPushButton("Play")
        self.play_button.clicked.connect(self.play_game)
        self.step_button = QPushButton("Step Frame")
        self.step_button.clicked.connect(self.step_frame)

        # Add controls to control_layout
        self.control_layout.addWidget(QLabel("FPS:"))
        self.control_layout.addWidget(self.fps_input)
        self.control_layout.addWidget(self.fps_button)
        self.control_layout.addWidget(QLabel("Game Speed:"))
        self.control_layout.addWidget(self.speed_input)
        self.control_layout.addWidget(self.speed_button)
        self.control_layout.addWidget(self.pause_button)
        self.control_layout.addWidget(self.play_button)
        self.control_layout.addWidget(self.step_button)

        # Search Bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Search Game Objects...")
        self.search_bar.textChanged.connect(self.filter_objects)
        self.search_layout.addWidget(QLabel("Search:"))
        self.search_layout.addWidget(self.search_bar)

        # Tabs for Properties
        self.tabs = QTabWidget()
        self.tabs.addTab(self.create_tab_widget("Physics"), "Physics")
        self.tabs.addTab(self.create_tab_widget("Game"), "Game")
        self.tabs.addTab(self.create_tab_widget("Transform"), "Transform")
        self.tabs.addTab(self.create_tab_widget("Materials"), "Materials")
        self.tabs.addTab(self.create_tab_widget("Animations"), "Animations")
        self.tabs.addTab(self.create_tab_widget("Logic Sensors"), "Logic Sensors")

        # Object List
        self.object_list_widget = QListWidget()
        self.object_list_widget.itemClicked.connect(self.select_object_from_list)

        # Selected Object Label
        self.selected_object_label = QLabel("Objects: ")
        self.selected_object_label.setAlignment(Qt.AlignCenter)
        self.selected_object = None
        

        # Instead, add these widgets directly to the main_layout:
        self.main_layout.addLayout(self.control_layout)
        self.main_layout.addLayout(self.search_layout)
        self.main_layout.addWidget(self.selected_object_label)
        self.main_layout.addWidget(self.object_list_widget)
        self.main_layout.addWidget(self.tabs)


        # Create a button to open the performance graph window
        self.open_graph_button = QPushButton("Open Performance Graph")
        self.open_graph_button.clicked.connect(self.open_performance_graph)
        self.main_layout.addWidget(self.open_graph_button)

        # Create the performance graph window (but don't show it yet)
        self.performance_graph_window = PerformanceGraphWindow()

        # # Add layouts to main layout
        self.left_layout.addLayout(self.control_layout)
        self.left_layout.addLayout(self.search_layout)
        self.left_layout.addWidget(self.selected_object_label)
        self.left_layout.addWidget(self.object_list_widget)
        self.left_layout.addWidget(self.tabs)

        self.main_layout.addLayout(self.left_layout)
        self.main_layout.addLayout(self.right_layout)
        self.setLayout(self.main_layout)

        # Performance data
        self.performance_data = []

        # Timer to collect performance data
        self.performance_timer = QTimer(self)
        self.performance_timer.timeout.connect(self.collect_performance_data)
        self.performance_timer.start(250)  # Collect data every second


        # Timer to update properties
        self.update_timer = QTimer(self)
        self.update_timer.timeout.connect(self.refresh_properties)
        self.update_timer.start(100)  # Update every 100 ms

        self.selected_object = None
        self.property_labels = {}
        self.property_entries = {}
        self.property_inputs = {}
        self.active_inputs = set()

        self.update_object_list()

    def create_tab_widget(self, category):
        """Creates a tab with a form layout for displaying properties."""
        widget = QWidget()
        layout = QFormLayout()
        widget.setLayout(layout)
        return widget

    def update_object_list(self):
        """Updates the list of game objects."""
        try:
            scene = bge.logic.getCurrentScene()
            
            # Only update the object list if search bar is empty
            if not self.search_bar.text():
                self.object_list_widget.clear()

                for obj in scene.objects:
                    item = QListWidgetItem(obj.name)
                    self.object_list_widget.addItem(item)
        except Exception as e:
            self.show_error("Error updating object list", e)
    
    def open_performance_graph(self):
        self.performance_graph_window.show()
    
    def update_performance_graph(self):
        if not self.performance_data:
            return

        current_time = time.time()

        # Update the graph in the separate window
        self.performance_graph_window.update_graph(self.performance_data)

        # Keep only the last 10 seconds of data
        self.performance_data = [d for d in self.performance_data if current_time - d['time'] <= 10]


    def collect_performance_data(self):
        stats = bge.logic.getProfileInfo()
        current_time = time.time()
        
        data_point = {
            'time': current_time,
            'gpu': stats.get('GPU Latency:', (0, 0))[0],
            'physics': stats.get('Physics:', (0, 0))[0],
            'rasterizer': stats.get('Rasterizer:', (0, 0))[0],
            'network': stats.get('Network:', (0, 0))[0],
            'logic': stats.get('Logic:', (0, 0))[0],
            'animations': stats.get('Animations:', (0, 0))[0]
        }
        
        self.performance_data.append(data_point)
        
        # Keep only the last 10 seconds of data
        self.performance_data = [d for d in self.performance_data if current_time - d['time'] <= 10]
        
        # Update the graph
        self.update_performance_graph()

        # Update the graph if the performance window is visible
        if self.performance_graph_window.isVisible():
            self.performance_graph_window.update_graph(self.performance_data)

    def filter_objects(self, text):
        """Filter the object list based on the search text."""
        try:
            text = text.lower()
            for i in range(self.object_list_widget.count()):
                item = self.object_list_widget.item(i)
                item.setHidden(text not in item.text().lower())
        except Exception as e:
            self.show_error("Error filtering objects", e)

    def select_object_from_list(self, item):
        """Selects a game object from the list."""
        self.selected_object = bge.logic.getCurrentScene().objects[item.text()]
        logging.info(f"Selected object: {self.selected_object.name}")
        self.highlight_selected_item(item)
        
        # Clear existing properties
        for tab_index in range(self.tabs.count()):
            tab = self.tabs.widget(tab_index)
            layout = tab.layout()
            self.clear_layout(layout)

        self.property_labels.clear()
        self.property_entries.clear()
        self.property_inputs.clear()
        
        self.setup_properties()
        self.selected_object_label.setText(f"Objects: {self.selected_object.name}")
        self.refresh_properties()

    def highlight_selected_item(self, selected_item):
        """Highlights the selected item in the object list."""
        for i in range(self.object_list_widget.count()):
            item = self.object_list_widget.item(i)
            if item == selected_item:
                # Set the background color to orange when selected
                item.setBackground(QColor("orange"))
            else:
                # Reset background color to white
                item.setBackground(QColor("white"))

    def setup_properties(self):
        """Setup initial property widgets for the selected object."""
        if not self.selected_object:
            return

        try:
            obj = self.selected_object  # self.selected_object is already a KX_GameObject
            if not obj:
                return
            
            # Clear existing properties
            for tab_index in range(self.tabs.count()):
                tab = self.tabs.widget(tab_index)
                if tab.layout():
                    self.clear_layout(tab.layout())
                    tab.layout().deleteLater()

            self.property_labels.clear()
            self.property_entries.clear()
            self.property_inputs.clear()

            # Remove any existing timers
            if hasattr(self, 'sensor_update_timer'):
                self.sensor_update_timer.stop()
                self.sensor_update_timer.deleteLater()

            # Populate each tab
            self.populate_physics_tab(obj)
            self.populate_game_tab(obj)
            self.populate_transform_tab(obj)
            self.populate_materials_tab(obj)
            self.populate_animations_tab(obj)
            self.populate_logic_sensors_tab(obj)

        except Exception as e:
            self.show_error(f"Error setting up properties for object {self.selected_object.name}", e)

   
    def populate_physics_tab(self, obj):
        """Populate the physics tab with object physics properties."""
        tab = self.tabs.widget(0)
        layout = tab.layout()
        self.clear_layout(layout)  # Clear any previous layout items

        if obj.getPhysicsId():
            self.create_vector_property_row(layout, obj, "linearVelocity")
            self.create_vector_property_row(layout, obj, "angularVelocity")
            self.create_scalar_property_row(layout, obj, "mass")
        else:
            layout.addRow(QLabel("No physics properties available."))

    def populate_game_tab(self, obj):
        """Populate the game tab with object game properties."""
        tab = self.tabs.widget(1)
        
        # Check if the tab already has a layout
        if tab.layout() is None:
            main_layout = QVBoxLayout(tab)
        else:
            main_layout = tab.layout()
            self.clear_layout(main_layout)

        # Add search bar
        self.game_search_bar = QLineEdit()
        self.game_search_bar.setPlaceholderText("Search properties...")
        self.game_search_bar.textChanged.connect(self.filter_game_properties)
        main_layout.addWidget(self.game_search_bar)

        # Create a list widget for properties
        self.game_property_list = QListWidget()
        main_layout.addWidget(self.game_property_list)

        # Add properties to the list
        for key in obj.getPropertyNames():
            self.add_game_property_item(obj, key)

        # Connect item selection to display property details
        self.game_property_list.itemClicked.connect(lambda item: self.display_property_details(obj, item.text()))

        # Create a widget for property details
        self.property_details_widget = QWidget()
        self.property_details_layout = QHBoxLayout(self.property_details_widget)
        main_layout.addWidget(self.property_details_widget)


    def add_game_property_item(self, obj, property_name):
        """Add a game property item to the list."""
        item = QListWidgetItem(property_name)
        self.game_property_list.addItem(item)

    def filter_game_properties(self, search_text):
        """Filter game properties based on search text."""
        search_text = search_text.lower()
        for i in range(self.game_property_list.count()):
            item = self.game_property_list.item(i)
            item.setHidden(search_text not in item.text().lower())

    def display_property_details(self, obj, property_name):
        """Display details of the selected property."""
        # Clear previous details
        self.clear_layout(self.property_details_layout)

        current_value = truncate(obj[property_name]) if property_name in obj else None
        
        # Create widgets for property details
        value_label = QLabel(f"Current value: {current_value}")
        input_field = QLineEdit()
        input_field.setPlaceholderText("New value")
        input_field.setFixedWidth(100)
        update_button = QPushButton("Update")
        update_button.clicked.connect(lambda: self.update_game_property(obj, property_name, input_field.text()))

        # Add widgets to the details layout
        self.property_details_layout.addWidget(value_label)
        self.property_details_layout.addWidget(input_field)
        self.property_details_layout.addWidget(update_button)

    def update_game_property(self, obj, property_name, new_value):
        """Update the game property with the new value."""
        try:
            if property_name in obj:
                current_type = type(obj[property_name])
                if current_type is float:
                    obj[property_name] = float(new_value)
                elif current_type is int:
                    obj[property_name] = int(new_value)
                elif current_type is bool:
                    obj[property_name] = new_value.lower() in ('true', '1', 'yes')
                else:
                    obj[property_name] = new_value

                # Refresh the displayed value
                self.display_property_details(obj, property_name)
                logging.info(f"Updated {property_name} of {obj.name} to {new_value}")
        except Exception as e:
            self.show_error(f"Error updating property {property_name}", e)

  

    def create_scalar_property_row(self, layout, obj, property_name):
        """Creates a row with a label for the property value and an input for editing."""
        try:
            # Get current value
            current_value = truncate(obj[property_name]) if property_name in obj else None
            input_field = QLineEdit()
            input_field.setPlaceholderText("New value")
            input_field.setFixedWidth(100)
            # input_field.setAlignment(Qt.AlignLeft)
            input_field.installEventFilter(self)
            input_field.setProperty("property_name", property_name)  # Store property name as a property

            update_button = QPushButton("Update")
            update_button.setFixedWidth(60)
            update_button.clicked.connect(lambda: self.update_scalar_property(obj, property_name, input_field.text()))

            label = QLabel(f"{property_name}: {current_value}")
            # unitlabel = QLabel("Kg")
            # input_field.setAlignment(Qt.AlignLeft)
            self.property_labels[property_name] = label
            self.property_entries[property_name] = input_field

            hbox = QHBoxLayout()
            hbox.addWidget(label)
            hbox.addWidget(input_field)
            # hbox.addWidget(label)
            hbox.addWidget(update_button)

            # Create a widget to hold the horizontal layout
            row_widget = QWidget()
            row_widget.setLayout(hbox)
            row_widget.setProperty("property_name", property_name)  # Store property name as a property

            layout.addRow(row_widget)

        except Exception as e:
            self.show_error(f"Error creating property row for {property_name}", e)

    def populate_transform_tab(self, obj):
        """Populate the transform tab with object transform properties."""
        tab = self.tabs.widget(2)
        layout = tab.layout()
        self.clear_layout(layout)  # Clear any previous layout items

        self.create_vector_property_row(layout, obj, "worldPosition", label="Position")
        self.create_rotation_property_row(layout, obj)  # New method for rotation
        self.create_vector_property_row(layout, obj, "worldScale", label="Scale")

    def create_rotation_property_row(self, layout, obj):
        """Creates a row for rotation property with inputs for each axis in degrees."""
        try:
            euler = obj.worldOrientation.to_euler()
            components = ['X', 'Y', 'Z']
            hbox = QHBoxLayout()

            for i, component in enumerate(components):
                value = math.degrees(euler[i])

                input_field = QLineEdit()
                input_field.setPlaceholderText(component)
                input_field.setFixedWidth(50)
                input_field.setAlignment(Qt.AlignLeft)
                input_field.installEventFilter(self)
                input_field.property_name = f"rotation_{component}"

                current_value_label = QLabel(f"{component}: {truncate(value)}°")
                self.property_inputs[f"rotation_{component}"] = input_field
                self.property_labels[f"rotation_{component}"] = current_value_label

                hbox.addWidget(input_field)
                hbox.addWidget(current_value_label)

            update_button = QPushButton("Update")
            update_button.setFixedWidth(60)
            update_button.clicked.connect(lambda: self.update_rotation_property(obj))

            hbox.addWidget(update_button)
            layout.addRow("Rotation (degrees):", hbox)

        except Exception as e:
            self.show_error(f"Error creating rotation property row", e)

    def update_rotation_property(self, obj):
        """Updates the object's rotation property with new component values in degrees."""
        try:
            components = ['X', 'Y', 'Z']
            new_rotation = []
            for component in components:
                input_field = self.property_inputs.get(f"rotation_{component}")
                if input_field:
                    new_value = input_field.text().strip()
                    if new_value:
                        new_value = math.radians(float(new_value))  # Convert degrees to radians
                        new_rotation.append(new_value)
                    else:
                        new_rotation.append(obj.worldOrientation.to_euler()[components.index(component)])

            obj.worldOrientation = mathutils.Euler(new_rotation)

            # Update the labels to reflect the new rotation values
            for i, component in enumerate(components):
                label = self.property_labels.get(f"rotation_{component}")
                if label:
                    display_value = math.degrees(new_rotation[i])
                    label.setText(f"{component}: {truncate(display_value)}°")

            # Clear the input fields after updating
            for component in components:
                input_field = self.property_inputs.get(f"rotation_{component}")
                if input_field:
                    input_field.clear()

            logging.info(f"Updated rotation of {obj.name} to {new_rotation}")
        except Exception as e:
            self.show_error(f"Error updating rotation property", e)

    def populate_materials_tab(self, obj):
        """Populate the materials tab with object material properties."""
        tab = self.tabs.widget(3)
        layout = tab.layout()
        self.clear_layout(layout)  # Clear any previous layout items

        if hasattr(obj, 'meshes') and obj.meshes:
            materials = [mat.name for mat in obj.meshes[0].materials]
            layout.addRow("Materials:", QLabel(", ".join(materials)))
        else:
            layout.addRow(QLabel("No materials available."))

    def populate_animations_tab(self, obj):
        """Populate the animations tab with object animation properties."""
        tab = self.tabs.widget(4)
        layout = tab.layout()
        self.clear_layout(layout)  # Clear any previous layout items

        layout.addRow(QLabel("No animation data available."))  # Placeholder for animation data

    def populate_logic_sensors_tab(self, obj):
        """Populate the logic sensors tab with object logic sensors and actuators."""
        tab = self.tabs.widget(5)
        layout = tab.layout()
        self.clear_layout(layout)  # Clear any previous layout items

        # Create two panes
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)

        # Sensors pane
        sensors_widget = QWidget()
        sensors_layout = QVBoxLayout(sensors_widget)
        sensors_label = QLabel("Sensors:")
        sensors_layout.addWidget(sensors_label)
        self.sensors_list = QListWidget()
        sensors_layout.addWidget(self.sensors_list)
        splitter.addWidget(sensors_widget)

        # Actuators pane
        actuators_widget = QWidget()
        actuators_layout = QVBoxLayout(actuators_widget)
        actuators_label = QLabel("Actuators:")
        actuators_layout.addWidget(actuators_label)
        self.actuators_list = QListWidget()
        actuators_layout.addWidget(self.actuators_list)
        splitter.addWidget(actuators_widget)

        # Populate sensors list
        if hasattr(obj, 'sensors'):
            for sensor in obj.sensors:
                item = QListWidgetItem(sensor.name)
                item.setData(Qt.UserRole, sensor)
                self.sensors_list.addItem(item)

            # Connect signals
            self.sensors_list.itemClicked.connect(self.on_sensor_clicked)
        
            # Start a timer to update sensor states
            self.sensor_update_timer = QTimer(self)
            self.sensor_update_timer.timeout.connect(lambda: self.update_sensor_states(obj))
            self.sensor_update_timer.start(100)  # Update every 100 ms
        else:
            self.sensors_list.addItem("No sensors available")
            self.actuators_list.addItem("No actuators available")

     
    def on_sensor_clicked(self, item):
        sensor = item.data(Qt.UserRole)
        self.actuators_list.clear()
        for controller in sensor.controllers:
            for actuator in controller.actuators:
                self.actuators_list.addItem(actuator.name)

    def update_sensor_states(self, obj):
        for i in range(self.sensors_list.count()):
            item = self.sensors_list.item(i)
            sensor = item.data(Qt.UserRole)
            if sensor.positive:
                item.setBackground(QColor("orange"))
            else:
                item.setBackground(QColor("white"))

    def create_rotation_property_row(self, layout, obj):
        """Creates a row for rotation property with inputs for each axis in degrees."""
        try:
            euler = obj.worldOrientation.to_euler()
            components = ['X', 'Y', 'Z']
            hbox = QHBoxLayout()

            for i, component in enumerate(components):
                value = math.degrees(euler[i])

                input_field = QLineEdit()
                input_field.setPlaceholderText(component)
                input_field.setFixedWidth(50)
                input_field.setAlignment(Qt.AlignLeft)
                input_field.installEventFilter(self)
                input_field.property_name = f"rotation_{component}"

                current_value_label = QLabel(f"{component}: {truncate(value)}°")
                self.property_inputs[f"rotation_{component}"] = input_field
                self.property_labels[f"rotation_{component}"] = current_value_label

                hbox.addWidget(input_field)
                hbox.addWidget(current_value_label)

            update_button = QPushButton("Update")
            update_button.setFixedWidth(60)
            update_button.clicked.connect(lambda: self.update_rotation_property(obj))

            hbox.addWidget(update_button)
            layout.addRow("Rotation (degrees):", hbox)

        except Exception as e:
            self.show_error(f"Error creating rotation property row", e)

    # def create_scalar_property_row(self, layout, obj, property_name):
    #     """Creates a row with a label for the property value and an input for editing."""
    #     try:
    #         # Get current value
    #         current_value = truncate(obj[property_name]) if property_name in obj else None
    #         input_field = QLineEdit()
    #         input_field.setPlaceholderText("New value")
    #         input_field.setFixedWidth(100)
    #         input_field.setAlignment(Qt.AlignLeft)
    #         input_field.installEventFilter(self)
    #         input_field.property_name = property_name  # Store property name in the input field

    #         update_button = QPushButton("Update")
    #         update_button.setFixedWidth(60)
    #         update_button.clicked.connect(lambda: self.update_scalar_property(obj, property_name, input_field.text()))

    #         label = QLabel(f"{property_name}: {current_value}")
    #         self.property_labels[property_name] = label
    #         self.property_entries[property_name] = input_field

    #         hbox = QHBoxLayout()
    #         hbox.addWidget(input_field)
    #         hbox.addWidget(label)
    #         hbox.addWidget(update_button)

    #         layout.addRow(hbox)

    #     except Exception as e:
    #         self.show_error(f"Error creating property row for {property_name}", e)

    def create_vector_property_row(self, layout, obj, property_name, label=None, degrees=False, is_euler=False):
        try:
            if label is None:
                label = property_name

            if property_name == "worldOrientation" and is_euler:
                vector = obj.worldOrientation.to_euler()
            else:
                vector = getattr(obj, property_name, None)
            
            if vector is not None:
                components = ['X', 'Y', 'Z']
                hbox = QHBoxLayout()

                for i, component in enumerate(components):
                    value = vector[i]
                    if degrees:
                        value = math.degrees(value)

                    input_field = QLineEdit()
                    input_field.setPlaceholderText(component)
                    input_field.setFixedWidth(50)
                    input_field.setAlignment(Qt.AlignLeft)
                    input_field.installEventFilter(self)
                    input_field.property_name = f"{property_name}_{component}"

                    current_value_label = QLabel(f"{component}: {truncate(value)}")
                    self.property_inputs[f"{property_name}_{component}"] = input_field
                    self.property_labels[f"{property_name}_{component}"] = current_value_label

                    hbox.addWidget(input_field)
                    hbox.addWidget(current_value_label)

                update_button = QPushButton("Update")
                update_button.setFixedWidth(60)
                update_button.clicked.connect(lambda: self.update_vector_property(obj, property_name, degrees, is_euler))

                hbox.addWidget(update_button)
                layout.addRow(f"{label}:", hbox)

        except Exception as e:
            self.show_error(f"Error creating vector property row for {property_name}", e)

    def eventFilter(self, source, event):
        if event.type() == event.FocusIn:
            if hasattr(source, 'property_name'):
                self.active_inputs.add(source.property_name)
        elif event.type() == event.FocusOut:
            if hasattr(source, 'property_name'):
                self.active_inputs.discard(source.property_name)
        return super().eventFilter(source, event)

    def update_scalar_property(self, obj, property_name, new_value):
        """Updates the object's scalar property with the new value."""
        try:
            if property_name in obj:
                if new_value.strip():
                    current_type = type(obj[property_name])
                    if current_type is float:
                        obj[property_name] = float(new_value)
                    elif current_type is int:
                        obj[property_name] = int(new_value)
                    elif current_type is bool:
                        obj[property_name] = new_value.lower() in ('true', '1', 'yes')
                    else:
                        obj[property_name] = new_value

                    # Update the label to reflect the new value
                    self.property_labels[property_name].setText(f"{property_name}: {obj[property_name]}")
                    # Clear the input field after updating
                    self.property_entries[property_name].clear()

            logging.info(f"Updated {property_name} of {obj.name} to {new_value}")
        except Exception as e:
            self.show_error(f"Error updating property {property_name}", e)

    def update_vector_property(self, obj, property_name, degrees=False, is_euler=False):
        """Updates the object's vector property with new component values."""
        try:
            vector = obj.worldOrientation.to_euler() if property_name == "worldOrientation" and is_euler else getattr(obj, property_name)
            components = ['X', 'Y', 'Z']
            new_vector = []
            for i, component in enumerate(components):
                input_field = self.property_inputs.get(f"{property_name}_{component}")
                if input_field:
                    new_value = input_field.text().strip()
                    if new_value:
                        new_value = float(new_value)
                        if degrees:
                            new_value = math.radians(new_value)
                        new_vector.append(new_value)
                    else:
                        new_vector.append(vector[i])

            if is_euler:
                obj.worldOrientation = mathutils.Euler(new_vector).to_matrix()
            else:
                setattr(obj, property_name, mathutils.Vector(new_vector))

            # Update the labels to reflect the new vector values
            for i, component in enumerate(components):
                label = self.property_labels.get(f"{property_name}_{component}")
                if label:
                    display_value = math.degrees(new_vector[i]) if degrees else new_vector[i]
                    label.setText(f"{component}: {truncate(display_value)}")

            # Clear the input fields after updating
            for component in components:
                input_field = self.property_inputs.get(f"{property_name}_{component}")
                if input_field:
                    input_field.clear()

            logging.info(f"Updated {property_name} of {obj.name} to {new_vector}")
        except Exception as e:
            self.show_error(f"Error updating vector property {property_name}", e)

    def clear_layout(self, layout):
        if layout is not None:
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()
                if widget is not None:
                    widget.setParent(None)
                else:
                    self.clear_layout(item.layout())

    def refresh_properties(self):
        """Refreshes the displayed property values of the selected object."""
        try:
            if not self.search_bar.text():
                self.update_object_list()
            if self.selected_object:
                obj = self.selected_object  # self.selected_object is already a KX_GameObject
                if obj:
                    for prop_name, label in self.property_labels.items():
                        if prop_name not in self.active_inputs:
                            if prop_name.startswith('rotation_'):
                                component = prop_name.split('_')[1]
                                euler = obj.worldOrientation.to_euler()
                                value = math.degrees(euler['XYZ'.index(component)])
                                label.setText(f"{component}: {truncate(value)}°")
                            elif '_' in prop_name:  # Other vector properties
                                parts = prop_name.split('_')
                                component = parts[-1]
                                base_prop = '_'.join(parts[:-1])
                                vector = getattr(obj, base_prop, None)
                                if vector is not None and hasattr(vector, '__getitem__'):
                                    index = ['X', 'Y', 'Z'].index(component)
                                    value = vector[index]
                                    label.setText(f"{component}: {truncate(value)}")
                                else:
                                    label.setText(f"{prop_name}: N/A")
                            else:  # Scalar property
                                if hasattr(obj, prop_name):
                                    current_value = getattr(obj, prop_name)
                                elif prop_name in obj:
                                    current_value = obj[prop_name]
                                else:
                                    current_value = None
                                label.setText(f"{prop_name}: {truncate(current_value)}")
                    self.populate_logic_sensors_tab(obj)
        except Exception as e:
            self.show_error("Error refreshing properties", e)

    # def refresh_properties(self):
    #     """Refreshes the displayed property values of the selected object."""
    #     try:
    #         if not self.search_bar.text():
    #             self.update_object_list()
    #         if self.selected_object:
    #             obj = self.selected_object  # self.selected_object is already a KX_GameObject
    #             if obj:
    #                 for prop_name, label in self.property_labels.items():
    #                     if prop_name not in self.active_inputs:
    #                         if prop_name.startswith('rotation_'):
    #                             component = prop_name.split('_')[1]
    #                             euler = obj.worldOrientation.to_euler()
    #                             value = math.degrees(euler['XYZ'.index(component)])
    #                             label.setText(f"{component}: {truncate(value)}°")
    #                         elif '_' in prop_name:  # Other vector properties
    #                             base_prop, component = prop_name.split('_')
    #                             vector = getattr(obj, base_prop, None)
    #                             if vector is not None:
    #                                 index = ['X', 'Y', 'Z'].index(component)
    #                                 value = vector[index]
    #                                 label.setText(f"{component}: {truncate(value)}")
    #                         else:  # Scalar property
    #                             current_value = obj[prop_name] if prop_name in obj else None
    #                             label.setText(f"{prop_name}: {truncate(current_value)}")
    #                 self.populate_logic_sensors_tab(obj)
                    
    #     except Exception as e:
    #         self.show_error("Error refreshing properties", e)

    def set_fps(self):
        """Set the game's frames per second."""
        try:
            fps = float(self.fps_input.text())
            bge.logic.setLogicTicRate(fps)
            logging.info(f"FPS set to {fps}")
        except ValueError as e:
            self.show_error("Invalid FPS value.", e)

    def set_game_speed(self):
        """Set the game speed."""
        try:
            speed = float(self.speed_input.text())
            bge.logic.setTimeScale(speed)
            logging.info(f"Game speed set to {speed}")
        except ValueError as e:
            self.show_error("Invalid game speed value.", e)

    def pause_game(self):
        """Pause the game."""
        try:
            bge.logic.setTimeScale(0)
            logging.info("Game paused.")
        except Exception as e:
            self.show_error("Error pausing the game.", e)

    def play_game(self):
        """Resume the game."""
        try:
            bge.logic.setTimeScale(1)
            logging.info("Game resumed.")
        except Exception as e:
            self.show_error("Error resuming the game.", e)

    def step_frame(self):
        """Step the game one frame forward."""
        try:
            bge.logic.nextFrame()
            logging.info("Stepped one frame forward.")
        except Exception as e:
            self.show_error("Error stepping the frame.", e)

    def toggle_physics_visualization(self):
        """Toggle physics visualization."""
        try:
            # Placeholder for actual physics visualization toggling
            logging.info("Physics visualization toggled (not implemented).")
        except Exception as e:
            self.show_error("Error toggling physics visualization.", e)

    def toggle_mouse(self):
        """Toggle mouse visibility."""
        global mouse_visible
        try:
            mouse_visible = not mouse_visible
            bge.render.showMouse(mouse_visible)
            logging.info(f"Mouse visibility set to {mouse_visible}")
        except Exception as e:
            self.show_error("Error toggling mouse visibility.", e)

    def show_error(self, message, exception=None):
        """Display an error message box with the provided message and exception details."""
        error_msg = message
        if exception:
            error_msg += f"\n\n{str(exception)}"
            error_msg += f"\n\nTraceback:\n{traceback.format_exc()}"

        msg_box = QMessageBox(self)
        msg_box.setIcon(QMessageBox.Critical)
        msg_box.setWindowTitle("Error")
        msg_box.setText(error_msg)
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.setWindowModality(Qt.ApplicationModal)
        msg_box.exec_()

        # Log to file
        logging.error(error_msg)

class PerformanceGraphWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BGE Performance Graph")
        self.setGeometry(300, 300, 800, 500)  # Adjust size as needed

        layout = QVBoxLayout()
        self.setLayout(layout)

        self.graph_widget = pg.PlotWidget()
        self.graph_widget.setBackground('w')
        self.graph_widget.setTitle("BGE Performance")
        self.graph_widget.setLabel('left', 'Time (ms)')
        self.graph_widget.setLabel('bottom', 'Time (s)')
        # self.graph_widget.addLegend()

        layout.addWidget(self.graph_widget)

        self.legend = pg.LegendItem(offset=(70, 30))
        self.legend.setParentItem(self.graph_widget.graphicsItem())

        self.curves = {
            'gpu': self.graph_widget.plot(pen='r', name='GPU'),
            'physics': self.graph_widget.plot(pen='g', name='Physics'),
            'rasterizer': self.graph_widget.plot(pen='b', name='Rasterizer'),
            'network': self.graph_widget.plot(pen='c', name='Network'),
            'logic': self.graph_widget.plot(pen='m', name='Logic'),
            'animations': self.graph_widget.plot(pen='y', name='Animations')
        }

        for name, curve in self.curves.items():
            self.legend.addItem(curve, name)

        self.performance_data = []

    def update_graph(self, performance_data):
        if not performance_data:
            return

        current_time = time.time()
        self.performance_data = performance_data

        # Update graph
        for key, curve in self.curves.items():
            times = [d['time'] - current_time + 10 for d in self.performance_data]
            values = [d[key] for d in self.performance_data]
            curve.setData(times, values)

        ###################################################

        self.graph_widget.setXRange(0, 10, padding=0)
        max_value = max(max(d[key] for d in self.performance_data) for key in self.curves.keys())
        self.graph_widget.setYRange(0, max_value * 1.1, padding=0)

        ###########################################################   


        # Update legend with milliseconds and percentages
        if self.performance_data:
            latest_data = self.performance_data[-1]
            total_time = sum(latest_data[key] for key in self.curves.keys())

            for i, (key, curve) in enumerate(self.curves.items()):
                value = latest_data[key]
                percentage = (value / total_time) * 100 if total_time > 0 else 0
                legend_text = f"{key}: {value:.2f} ms ({percentage:.1f}%)"
                self.legend.items[i][1].setText(legend_text)

        # Force a redraw of the graph
        self.graph_widget.update()


def truncate(value, digits=3):
    """Truncate a float or list of floats to a specific number of decimal places."""
    if isinstance(value, float):
        return round(value, digits)
    elif isinstance(value, (list, mathutils.Vector, mathutils.Euler)):
        return [truncate(v, digits) for v in value]
    return value

def run_gui():
    app = QApplication.instance()
    if app is None:
        app = QApplication(sys.argv)

    # Create and show the debugger window
    window = DebuggerWindow()
    window.show()

    return app, window

def start_gui(cont):
    try:
        # Get the game object
        obj = cont.owner

        # Check if the GUI is already initialized using an object property
        if 'gui_initialized' not in obj:
            obj['app'], obj['window'] = run_gui()
            obj['gui_initialized'] = True

        # Process PyQt5 events to keep the UI responsive
        if 'app' in obj:
            obj['app'].processEvents()

        # Update performance graph
        if 'window' in obj:
            obj['window'].update_performance_graph()

    except Exception as e:
        logging.error(f"Error initializing GUI: {e}")
        traceback.print_exc()

# Setup the logic brick to run this function every frame
if __name__ == "__main__":
    cont = bge.logic.getCurrentController()
    start_gui(cont)
